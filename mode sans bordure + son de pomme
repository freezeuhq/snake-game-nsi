import pygame 
import random
import sys 

 

# Initialiser pygame (permet de démarrer le code de pygame)
pygame.init()
pygame.mixer.init()


# Constantes en MAJ et ne vont jamais changer (définir les paramétres de l'interface graphique)
SCREEN_WIDTH = 750 # LARGEUR
SCREEN_HEIGHT = 750 # HAUTEUR 
CELL_SIZE = 25 # UNE CELLULE (un carré)
GRID_SIZE = SCREEN_WIDTH // CELL_SIZE # division entiére largeur(fenetre)//largeur d'une cellule 750//25 il y aura 30 cases
FPS = 7.5 # combien de fois par seconde la fenetre va s'actualiser , j'ai mit 10 fps car le serpent se déplace d'une case a la fois et a 60 il ira trop vite

# Couleurs (tuple de couleur avec les canneaux rgb)

SNAKE_COLOR  = (248, 168, 0)# couleur du serpent = jaune 
BACKGROUND_COLOR = (184, 56, 0) # couleur de  fond = noir un peu orrangé
APPLE_COLOR = (1, 252, 128) # couleur de la pomme = vert
BORDER_COLOR = (232, 168, 0) # couleur de la bordure = orange
SCORE_COLOR = (248, 252, 248) # couleur du score = blanc

# Creé l'interface graphique

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) # on apelle pygame puis le module display et on en retire la fonction set.mode et on lui indique la taille de la fenetre
pygame.display.set_caption("Snake") # initulé a la fenetre

font = pygame.font.Font(None, 36) # la police sera de taille 36 et None ca veut dire qu'il prend pas un style de police particulières 

class Snake:
    def __init__(self):
        self.positions = [(5, 5), (4,5), (3,5)] # coordonnée du snake dans le plan il a une longueur de 3 sa tete et le premier tuple
        self.direction = (1,0) # direction du serpent (de droite a gauche)
        self.grow = False # attribut qui va changer
    
    def move(self):
        # 1. Récupération de la tête actuelle
        head_x, head_y = self.positions[0]
        delta_x, delta_y = self.direction

        # 2. Calcul de la nouvelle position (avec effet "boucle" sur la grille)
        new_x = (head_x + delta_x) % GRID_SIZE
        new_y = (head_y + delta_y) % GRID_SIZE
        new_head = (new_x, new_y)

        # 3. Gestion des collisions (auto-collision uniquement)
        if new_head in self.positions:
            return False  # Game Over

        # 4. Insertion de la nouvelle tête
        self.positions.insert(0, new_head)

        # 5. Gestion de la croissance
        if not self.grow:
            self.positions.pop()  # On enlève la queue si on ne grandit pas
        else:
            self.grow = False  # Le serpent a grandi, on réinitialise

        return True


    
    def change_direction(self, direction):
        
        opposite_direction = (-self.direction[0], -self.direction[1])
        if direction != opposite_direction:
            self.direction = direction 

    def grow_snake(self):
        self.grow = True 

    def draw(self, surface):
        for x, y in self.positions:
            rect = pygame.Rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE)
            pygame.draw.rect(surface, SNAKE_COLOR, rect)


        #Ajouter des yeux au snake 
        head_x, head_y = self.positions[0]
        eye1 = pygame.Rect(head_x * CELL_SIZE + 8, head_y * CELL_SIZE + 8, 5, 5)
        eye2 = pygame.Rect(head_x * CELL_SIZE + 17, head_y *CELL_SIZE + 8, 5, 5)
        pygame.draw.rect(surface, (0, 0, 0), eye1)
        pygame.draw.rect(surface, (0, 0, 0), eye2)




class Apple:

    def __init__(self, snake):
        self.position = self.random_position(snake)


    def random_position(self, snake):
        running = True
        while running:
            position = (random.randint(1, GRID_SIZE - 2), random.randint(1, GRID_SIZE - 2))
            if position not in snake.positions :
                running = False
        return position
    
    def draw(self, surface):
         rect = pygame.Rect(self.position[0] * CELL_SIZE, self.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE)
         pygame.draw.rect(surface, APPLE_COLOR, rect)


def draw_background(surface):
    surface.fill(BACKGROUND_COLOR)

def draw_border(surface):
    pygame.draw.rect(surface, BORDER_COLOR, pygame.Rect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT), CELL_SIZE)

def display_score(surface, score):
    text = font.render(f"Score: {score}", True, SCORE_COLOR)
    surface.blit(text, (10,10))

def game_over_screen(surface, score):
    game_over_text = font.render("GAME OVER", True , SCORE_COLOR)
    score_text = font.render(f"Score: {score}", True, SCORE_COLOR)
    restart_text = font.render("Press Space to Restart", True, SCORE_COLOR)
    surface.blit(game_over_text, (SCREEN_WIDTH // 2 - game_over_text.get_width() // 2, SCREEN_HEIGHT // 4))
    surface.blit(score_text, (SCREEN_WIDTH // 2 - score_text.get_width() // 2, SCREEN_HEIGHT // 3))
    surface.blit(restart_text, (SCREEN_WIDTH // 2 - restart_text.get_width() // 2, SCREEN_HEIGHT // 2))

def victory_screen(surface, score):
    victory_text = font.render("YOU WIN!" , True , SCORE_COLOR)
    score_text = font.render(f"Score: {score}" , True , SCORE_COLOR)
    restart_text = font.render("Press Space to Restart", True, SCORE_COLOR)
    surface.blit(victory_text, (SCREEN_WIDTH // 2 - victory_text.get_width() // 2, SCREEN_HEIGHT // 4))
    surface.blit(score_text, (SCREEN_WIDTH // 2 - score_text.get_width() // 2, SCREEN_HEIGHT // 3))
    surface.blit(restart_text, (SCREEN_WIDTH // 2 - restart_text.get_width() // 2, SCREEN_HEIGHT // 2))



def main():

    clock = pygame.time.Clock()
    snake = Snake()
    apple = Apple(snake)
    score = 0
    eat_sound = pygame.mixer.Sound("eat.wav")

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:
                    snake.change_direction((0 , -1))
                elif event.key == pygame.K_DOWN:
                    snake.change_direction((0, 1))
                elif event.key == pygame.K_LEFT:
                    snake.change_direction((-1,0))
                elif event.key == pygame.K_RIGHT:
                    snake.change_direction((1,0))
                elif event.key == pygame.K_SPACE:
                    if not running:
                        main()

        if not snake.move():
            game_over_screen(screen, score)
            pygame.display.flip()
            running = False
            while True:
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
                        sys.exit()
                    elif event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_SPACE:
                            main()

                    
        
        if snake.positions[0] == apple.position:
            snake.grow_snake()
            apple = Apple(snake)
            score += 1
            eat_sound.play()




        draw_background(screen)
        draw_border(screen)
        snake.draw(screen)
        apple.draw(screen)
        display_score(screen, score)
        pygame.display.flip()
        clock.tick(FPS)



        if len(snake.positions) == (GRID_SIZE-2) * (GRID_SIZE-2):
            victory_screen(screen,score)
            pygame.display.flip()
            running = False
            while True:
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
                        sys.exit()
                    elif event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_SPACE:
                            main()

main()

                


    
    



 





 



